# 1-1 TDD

## 요구사항
### `기본과제`

- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
- 주어진 4가지 기능에 대한 단위 테스트 작성

### `심화과제`

- 동일한 사용자에 대한 동시 요청이 정상적으로 처리될 수 있도록 개선
- 주어진 4가지 기능에 대한 통합 테스트 작성
- **선택한 언어에 대한** 동시성 제어 방식 및 각 적용의 장/단점을 기술한 보고서 작성 ( **README.md** )


## 동시성 프로그래밍에서 문제가 발생하는 원인
CPU가 작업을 처리할 때 공유자원인 RAM에서 일부분을 성능이 좋은 CPU Cache Memory로 읽어 들인 이후에, 작업을 수행하고 CPU Cache Memory에 작업을 반영하고 이후에 RAM에 반영하게 됩니다.

위 작업이 멀티 스레드 환경에서 병렬적으로 수행하게 된다면, RAM에 있는 공유 자원에 접근할 때 가시성 문제와 원자성 문제가 밸생할 수 있습니다.

가시성 문제란 여러 개의 스레드가 병렬적으로 처리하게 되면서 CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않게 되는 문제입니다.

원자성 문제는 한 스레드가 작업을 수행하는 동안 다른 스레드가 개입하여 공유 자원에 접근하여 같은 작업을 수행함으로써 발생하는 문제입니다.

자바는 static, heap, stack 영역으로 나누어져 있는데, 멀티 스레드 환경에서 static, heap 영역을 공유하므로 위와 같은 문제가 동일하게 발생할 수 있습니다.

## 자바에서 동시성 문제를 해결하는 키워드

### volatile
volatile는 가시성 문제를 해결하기 위한 키워드로, 해당 키워드를 사용한 변수는 메인 메모리로부터 읽을 수 있게 해줍니다.

장점
- 메인 메모리에 직접 쓰고, 읽을 수 있게하여, CPU Cache Memory와 메인 메모리의 데이터가 다를 때 발생하는 가시성 문제를 해결할 수 있습니다.

단점
- 한 스레드가 데이터를 읽고 작업을 하는 중에 다른 스레드가 해당 데이터를 수정하는 것은 막지 못하기 때문에 원자성 문제를 해결하지 못합니다.

### synchronized
synchronized는 원자성을 보장하기 위한 키워드로, 메소드 또는 블록에 붙여 지정한 범위에서 해당 자원을 사용할 때 다른 스레드가 동시에 사용할 수 없도록 Lock을 걸고 범위에서 벗어나면 Lock을 푸는 방식입니다.

사용하는 방식으로는 sychronized method, sychronized block, static sychronized method, static synchonized block 이 있고 각각 의 방식을 사용하면 클래스 단위 또는 인스턴스 단위로 lock을 공유하게 됩니다.

장점 
- 한 스레드가 공유 자원을 사용할 때 Lock을 사용하여, 다른 스레드가 접근할 수 없기 때문에 동시성 문제를 해결할 수 있습니다.
- 자동으로 락이 해제되어서 데드락 발생 위험이 줄어듭니다.

단점
- 객체 or 인스턴스 단위로 하나의 synchronized 범위에 Lock이 걸려도 다른 synchronized 범위에서도 Lock을 공유하기 때문에, 효율적으로 Lock의 범위를 제한할 수 없습니다.
- 순서를 보장하지 않기 때문에, 여러 스레드가 대기하고 있을 때 어떤 스레드가 획득할 지 알 수 없어서 공정성 문제가 발생합니다.
- 락을 획득할 때까지 대기하며 위 공정성 문제와 함께 발생하게 되면 락을 계속해서 획득하지 못하는 기아 현상이 발생합니다.

### atomic
tomic은 원자성을 보장하기 위한 키워드로, synchronized와 달리 CAS(Compared And Swap)알고리즘으로 작동합니다.
CAS 알고리즘은 CPU Cache Memory와 RAM을 비교하여 일치한다면 CPU Cache Memory와 RAM에 적용하고, 일치하지 않는다면 재시도함으로써 어떠한 스레드에서 공유 자원에 읽기/쓰기 작업을 하더라도 원자성을 보장합니다.
자바의 Concurrent 패키지의 타입들이 CAS 알고리즘을 이용해 원자성을 보장합니다.

### ReentrantLock
ReentrantLock은 락을 획득/해제하는 시점을 명시적으로 관리함으로써 임계 구역을 안전하게 보호할 수 있도록 합니다.
synchronized가 제공하지 않는 다양한 기능들을 제공합니다.

장점
- 생성할 때 공정성을 설정할 수 있어 오래 기다린 스레드가 우선적으로 락을 획득할 수 있게 합니다.
- 동일한 스레드가 이미 획득한 락을 다시 획득할 수 있습니다. (CAS 알고리즘 사용)
- 락 획득 시도 후 성공여부를 반환해서 따로 로직을 처리할 수도 있고, 시간 제한을 두고 시도할 수도 있습니다.
- 락을 대기하는 중에 인터럽트 처리를 할 수 있습니다.

단점
- 락을 획득하고, 해제하는 시점을 명시적으로 지정해야 하는데, 락을 획득하고 해제하지 않았다면 데드락 발생 위험이 있습니다.
- 락에 대한 공정성을 설정했을 때 성능이 떨어질 수 있습니다.

### ConcurrentHashMap
ConcurrentHashMap은 멀티 스레드 환경에서 여러 스레드가 동시에 읽고 쓰는 작업을 수행해도 데이터의 일관성을 유지하는 Map입니다.
ConcurrentHashMap은 Map단위가 아닌 버킷 단위로 락을 분할하여 put, remove 등의 작업도 버킷 단위로 병렬 처리가 가능합니다.

장점
- 버킷 단위로 락을 분할하였기 때문에 병렬 처리가 가능하여 효율적으로 동시성을 보장할 수 있습니다. 

단점
- 버킷을 사용하여 HashMap보다 메모리 사용량이 많습니다.
- 순서를 보장하지 않기 때문에 공정성 문제가 발생합니다.

### ReentrantLock + ConcurrentHashMap
락을 관리할 수 있는 ReentrantLock과 멀티 스레드 환경에서 버킷 단위로 데이터의 일관성을 유지해주는 ConcurrentHashMap을 사용하면, 특정 기준(버킷)을 이용하여 락을 관리함으로써 락이 제한하는 범위를 최소한으로 잡을 수 있게 됩니다.

장점
- 버킷 단위로 락을 관리하기 때문에 다른 버킷에 대한 작업을 병렬로 처리가 가능하여 성능이 향상됩니다.
- ReentrantLock은 공정성 설정을 제공하기 때문에 같은 버킷에서의 공정성도 제어할 수 있습니다.

단점
- 버킷이 많아지면 메모리 사용량이 증가할 수 있습니다.
- 버킷 단위로 항상 매번 락을 생성한다면 성능이 저하될 수 있습니다.
- 여러 스레드가 같은 버킷에 접근할 경우 락 경쟁이 심화될 수 있습니다.
- ReentrantLock을 명시적으로 해제하지 않으면 데드락 발생 위험이 있습니다.


## 1주차 과제에서 사용할 동시성 제어 방법
1주차 과제에서 같은 유저가 포인트를 멀티 스레드 환경에서 수정하게 될 때 동시성 문제가 발생하게 됩니다.

공유 자원을 수정할 때 동시성 문제를 해결하기 위해서는 synchronized, ReentrantLock + ConcurrentHashMap을 사용할 수 있습니다.

synchronized를 사용하게 된다면 PointService 클래스 단위로 충전과 사용 메소드에 대해서 lock을 거는 방법을 사용할 수 있습니다.
이 때 발생할 수 있는 문제점은 A라는 사용자가 충전/사용을 할 때 B라는 사용자는 같은 데이터에 접근하지 않지만 A라는 사용자의 요청이 끝날 때까지 lock을 획들할 수 없게 되므로 동시성 문제는 해결 가능하지만 성능상 적합하지 않다고 생각합니다.

ReentrantLock + ConcurrentHashMap을 사용하게 되면 각 유저ID별로 버킷을 생성하여 락을 관리할 수 있게 됩니다. 유저는 다른 사람이 포인트를 충전/사용하여도 유저별 lock을 획득할 수 있게 되면서 LocK의 범위는 최소화하여 성능상에 이점을 얻을 수 있습니다.

위와 같은 이유로 ReentrantLock + ConcurrentHashMap을 사용하여 1주차 과제를 수행하였습니다.
